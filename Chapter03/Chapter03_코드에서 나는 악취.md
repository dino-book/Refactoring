## Chapter03 코드에서 나는 악취

#### 1. 기이한 이름

코드는 단순하고 명료하게 작성해야 한다. 코드를 명료하게 표현하는 데 가장 중요한 요소 중 하나는 바로 '이름'이다. 그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.

<br />

#### 2. 중복 코드

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다. 코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴 봐야 하는 부담이 생긴다. 그중 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.

<br />

#### 3. 긴 함수

오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다. 짧은 함수들로 구성된 코드 베이스를 얼핏 훑으면 연산하는 부분이 하나도 없어 보인다. 코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다. 하지만 이런 프로그램을 수 년 동안 다루다 보면 이 짧은 함수들이 얼마나 중요한지 깨닫게 된다. 간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.

짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다. 주석을 달아야 할 만한 부분은 웬만하면 함수로 만든다. 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다. 이렇게 함수로 묶는 코드는 여러 줄일 수도 있고 단 한 줄일 수도 있다. 심지어 원래 코드보다 더 길어지더라도 함수로 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다. 여기서 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가다. 즉, '무엇을 하는지'를 코드가 잘 설명해 주지 못할수록 함수로 만드는 게 유리하다.

함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다. 이런 상황에서 함수를 추출하다 보면 추출된 함수에도 매개변수가 너무 많아져서 리팩토링 전보다 난해해질 수 있다. 그렇다면 **임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를, **매개변수 객체 만들기**와 **객체 통째로 넘기기**로는 매개변수의 수를 줄일 수 있다. 여전히 임시 변수와 매개변수가 많다면 더 큰 수술이라고 할 수 있는 **함수를 명령으로 바꾸기**를 고려한다.

조건문은 **조건문 분해하기**로 대응한다. 거대한 `switch`문을 구성하는 `case`마다 **함수 추출하기**를 적용해서 각 `case`의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 `switch`문이 여러 개라면 **조건문을 다형성으로 바꾸기**를 적용한다.

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다. 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작 업이 섞여 있기 때문일 수 있다. 이럴 때는 과감히 **반복문 쪼개기**를 적용해서 작업을 분리한다.

<br />

#### 4. 긴 매개변수 목록

매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 **매개변수를 질의함수로 바꾸기**로 제거할 수 있다. 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 **객체 통째로 넘기기**를 적용해서 원본 데이터 구조를 그대로 전달한다. 항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**로 하나로 묶어버린다. 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없애 준다.

<br />

#### 5. 전역 데이터

전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다. 그래서 마치 '유령 같은 원격작용'처럼, 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 굉장히 어렵다. 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

이를 방지하기 위해서 사용하는 대표적인 리팩토링은 **변수 캡슐화하기**다. 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.

<br />

#### 6. 가변 데이터

코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다. 때문에 무분별한 데이터 수정에 따른 위험을 줄여야 한다.

가령 **변수 캡슐화하기**를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다. 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 **변수 쪼개기**를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다. 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. 그러기 위해 **문장 슬라이드하기**와 **함수 추출하기**를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다. API를 만들 때는 **질의 함수와 변경 함수 분리하기**를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다. 가능한 한 **세터 제거하기**도 적용한다.

변수의 유효 범위가 단 몇 줄뿐이라면 가변 데이터라 해도 문제를 일으킬 일이 별로 없다. 하지만 나중에 유효 범위가 넓어질 수 있고, 그러면 위험도 덩달아 커진다. 따라서 **여러 함수를 클래스로 묶기**나 **여러 함수를 변환 함수로 묶기**를 활용해서 변수를 갱신하는 코드들의 유효 범위를 제한한다. 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 **참조를 값으로 바꾸기**를 적용하여, 내부 필드를 직접 수정하지 않고 구조체를 통째로 교체하는 편이 낫다.

<br />

#### 7. 뒤엉킨 변경

뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

데이터베이스에서 데이터를 가져와서 금융 상품 로직에서 처리해야 하는 일처럼 순차적으로 실행되는 게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다(**단계 쪼개기**). 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다(**함수 옮기기**). 그러면 처리 과정이 맥락별로 구분된다. 이때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 **함수 추출하기**부터 수행한다. 모듈이 클래스라면 **클래스 추출하기**가 맥락별 분리 방법을 잘 안내해 줄 것이다.

<br />

#### 8. 산탄총 수술

코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생한다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.

이럴 때는 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어두면 좋다. 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶기를 적용한다. 데이터 구조를 변환하거나 보강하는 함수들에는 여러 함수를 변환 함수로 묶기를 적용한다. 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 단계 쪼개기를 적용한다.

어설프게 분리된 로직을 함수 인라인하기나 클래스 인라인하기 같은 인라인 리팩토링으로 하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법이다.

<br />

#### 9. 기능 편애

프로그램을 모듈화할 때는 코드를 여러 형식으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다. 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 많을 때 풍기는 냄새다.

<br />

#### 10. 데이터 뭉치

몰려다니는 데이터 뭉치는 보금자리를 따로 마련해 줘야 마땅하다.

가장 먼저 필드 형태의 데이터 뭉치를 찾아서 **클래스 추출하기**로 하나의 객체로 묶는다. 다음은 메서드 시그니처에 있는 데이터 뭉치 차례다. 먼저 **매개변수 객체 만들기**나 **객체 통째로 넘기기**를 적용해서 매개변수 수를 줄여 본다.

데이터 뭉치인지 판별하려면 값 하나를 삭제해 보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

<br />

#### 11. 기본형 집착

**기본형을 객체로 바꾸기**를 적용하면 기본형만이 거주하는 구석기 동굴을 의미 있는 자료형들이 사는 최신 온돌식 코드로 탈바꿈시킬 수 있다. 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 **타입 코드를 서브클래스로 바꾸기**와 **조건부 로직을 다형성으로 바꾸기**를 차례로 적용한다.

자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치다. 따라서 클래스 추출하기와 **매개변수 객체 만들기**를 이용한다.

<br />

#### 12. 반복되는 switch문

중복된 `switch`문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 `switch`문도 모두 찾아서 함께 수정해야 하기 때문이다. 이럴 때 다형성은 반복된 `switch`문이 내뿜는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔 주는 세련된 무기인 셈이다.

<br />

#### 13. 반복문

지금은 일급 함수를 지원하는 언어가 많아졌기 때문에, **반복문을 파이프라인으로 바꾸기**를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.

<br />

#### 14. 성의 없는 요소

프로그램 요소를 이용하면 좋다. 그래야 그 구조를 변경하거나 재활용할 기회가 생기고, 혹은 단순히 더 의미 있는 이름을 가졌기 때문이다. 그렇지만 그 구조가 필요 없을 때도 있다. 이런 프로그램 요소는 제거하는 게 좋다. 흔히 **함수 인라인하기**나 **클래스 인라인하기**로 처리한다. 상속을 사용했다면 **계층 합치기**를 적용한다.

<br />

#### 15. 추측성 일반화

추측성 일반화는 '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해 둔 코드에서 풍긴다. 그 결과는 물론 이해하거나 관리하기 어려워진 코드다. 마래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데없는 낭비일 뿐이다. 당장 걸리적 거리는 코드는 눈 앞에서 치워버린다.

하는 일이 거의 없는 추상 클래스는 **계층 합치기**로 제거한다. 쓸데없이 위임하는 코드는 **함수 인라인하기**나 클래스 인라인하기로 삭제한다. 본문에서 사용되지 않는 매개변수는 **함수 선언 바꾸기**로 없앤다. 나중에 다른 버전을 만들 때 필요할 거라는 생각에 추가했지만 한 번도 사용한 적 없는 매개변수도 이 기법으로 제거한다.

<br />

#### 16. 임시 필드

간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 있으리라 기대하는 게 보통이라, 이렇게 힘시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.

이렇게 덩그러니 떨어져 있는 필드들을 발견하면 **클래스 추출하기**로 제 살 곳을 찾아 준다. 그런 다음 **함수 옮기기**로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아 넣는다. 또한 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직이 있을 수 있는데, **특이 케이스 추가하기**로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할 수 있다.

<br />

#### 17. 메시지 체인

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

이 문제는 **위임 숨기기**로 해결한다. 이 리팩토링은 메시지 체인의 다양한 연결점에 적용할 수 있다. 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그러다 보면 중간 객체들이 모두 중개자가 돼버리기 쉽다. 그러니 취종 결과 객체가 어떻게 쓰이는지부터 살펴보는 게 좋다. **함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 함수 옮기기로 체인을 숨길 수 있는지 살펴본다. 체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중 그 이후의 객체들도 사용하길 원하는 게 제법 된다면, 이 요구를 처리해 줄 메서드를 추가한다.

<br />

#### 18. 중개자

객체의 대표적인 기능 중 하나로, 외부로부터 세부사항을 숨겨 주는 캡슐화가 있다. 캡슐화하는 과정에서는 위임이 자주 활용된다.

하지만 이 역시 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면? 이럴 때는 **중개자 제거하기**를 활용하여 실제로 일을 하는 객체와 직접 소통하게 한다. 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인한다.

<br />

#### 19. 내부자 거래

결합도가 높고, 은밀히 데이터를 주고 받는 모듈들이 있다면, **함수 옮기기**와 **필드 옮기기** 기법으로 뗴어 놓아서 사적으로 처리하는 부분을 줄인다. 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 **위임 숨기기**를 이용하여 다른 모듈이 중간자 역할을 하게 만든다. 